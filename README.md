# huawei_tls1.3
frozen, just architecture ideas


Как я в момент написания текста вижу то, что должно получиться в итоге:



нужно написать 2 системных демона (один для клиенской части, другой для серверной части),
каждый из которых работает по модели event-driven threading.
(т е в каждом демоне создаём тредов по числу ядер + один управляющий тред + структура данных которая хранит ивенты на обработку тредам)
 
+ написать 2 API для клиенской и серверной частей соответственно.
 
чтобы обеспечить параллельные read и write главному процессу было принято решение сделать их ассинхронными,
а саму запись и чтение, а также шифрование/дешифрование вынести в отдельный процесс, независимый от используемого и гарантировать
его доступность с помощью:
1) запуска как демона, т е интерфейсы по работе с данным процессом будут по идее доступны приложению, требующиму tls соединение
2)интерфейсы предоставленные программисту-пользователю создаваемой библиотеки основываются на обёртках над "извесными портами"
процесса-демона-обработчика_tls_соединения.
 
 
основные функции для клиенского интерфейса:
 
tls_init - устанавливает межпроцессорное взаимодействие с демоном
tls_destroy - разрушает установленное взаимодействие с демоном
tls_open - подать запрос на создание соединения
tls_close - подать запрос на закрытие соединения
tls_read - подать запрос на чтение
tls_write - подать запрос на запись
tls_try- проверить готовность запроса
tls_wait- дождаться готовности запроса
tls_try_cancell - (в той ситуации если пользователь установил таймер и хочет отменить запрос, а запрос долго находился в очереди обработки)
tls_barier - для разделения запросов чтения/записи (по задумке, чтение/запись из любого соединения происходит параллельно
(дуплексный канал связи)
т е код
tls_read;
tls_write;
возвращает сразу, и при добавлении ивентов в структуру обработки ивентов подразумевается что они могут быть обработанны параллельно
если вышестоящий алгоритм требует сначала чтение, потом запись, то нужно написать
tls_read;
tls_barier;
tls_write;
 
Как будет осуществляться запрос к демону?
 
Пример с tls_read:
1)генерируется уникальный идентификатор операции;
1)создаётся область с разделённой памятью между данным процессом и демоном;
2)туда копируются все параметры, указывается тип операции, создаётся место для возвращаемого значения, сохранения промежуточных вычислений и семафор, чтобы сообщить в случае завершения обработки запроса
3)с помощью очереди сообщений посылается идентификатор операции.
4)демон получает идентификатор, отображает соответствующую разделяемую память себе, на основе типа операции (в данном случае READ)
вставляет начало разделяемого адреса в структуру обработки ивентов;
5)когда подходит очередь обработки данного ивента, ивент обрабатывается одним из созданных по числу ядер тредов
6)обработка неблокирующая, в при инициализации демона в pthread_create передаётся одинаковая для всех тредов функия event_handler
которая в случае слишком долгой обработки запроса
а) сохраняет состояние в разделяемой памяти соответствующей операции
б) говорит управляющему треду, что данный тред свободен;
 
7) когда ивент обработан, с ошибкой или без, в общей памяти в в месте для возвращаемого значения записывается нужный результат обработки, семафор увеличивается на один, сообщая что обработка завершена
8)демон закрывает дескрипторы соответствующего ивента для разделяемой памяти, освобождает другие требуемые ресурсы
9)пользователь узнаёт о завершении обработки с помощью функци tls_try или tls_wait
10)пользователь освобождает ресурсы выделенные на операцию с помощью функции tls_oper_state_destroy
 
 
По сути функция event_handler в совокупности с состоянием в разделённой памяти - конечный автомат.
 
Для дальнейшего программирования мне нужны интерфейсы библиотек реализующих криптографию,
чтобы соответствующим образом сначала написать просто функции получения и обработки tls сообщений, а потом
преобразовать это в конечный автомат для обработки демоном.

